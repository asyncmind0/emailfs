<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 10">
<meta name=Originator content="Microsoft Word 10">
<link rel=File-List href="Project%20Report-N_files/filelist.xml">
<link rel=Edit-Time-Data href="Project%20Report-N_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title> </title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Tony A. Dsouza</o:Author>
  <o:LastAuthor>Vignesh Prabhu</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>3</o:TotalTime>
  <o:Created>2005-06-11T13:28:00Z</o:Created>
  <o:LastSaved>2005-06-11T13:28:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>8218</o:Words>
  <o:Characters>46847</o:Characters>
  <o:Company>Velantiny</o:Company>
  <o:Lines>390</o:Lines>
  <o:Paragraphs>109</o:Paragraphs>
  <o:CharactersWithSpaces>54956</o:CharactersWithSpaces>
  <o:Version>10.2625</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h2
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:18.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;
	font-weight:bold;}
h4
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:4;
	font-size:14.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
code
	{font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
samp
	{font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
tt
	{font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
p.first, li.first, div.first
	{mso-style-name:first;
	mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:151066361;
	mso-list-template-ids:9588298;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l1
	{mso-list-id:788931836;
	mso-list-template-ids:145099172;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l2
	{mso-list-id:839933090;
	mso-list-template-ids:322096332;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l3
	{mso-list-id:1035814269;
	mso-list-template-ids:-1687510726;}
@list l3:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l4
	{mso-list-id:1064764798;
	mso-list-template-ids:67698719;
	mso-list-style-name:Style1;}
@list l4:level1
	{mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;}
@list l4:level2
	{mso-level-text:"%1\.%2\.";
	mso-level-tab-stop:.75in;
	mso-level-number-position:left;
	margin-left:.55in;
	text-indent:-.3in;}
@list l4:level3
	{mso-level-text:"%1\.%2\.%3\.";
	mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	margin-left:.85in;
	text-indent:-.35in;}
@list l4:level4
	{mso-level-text:"%1\.%2\.%3\.%4\.";
	mso-level-tab-stop:1.5in;
	mso-level-number-position:left;
	margin-left:1.2in;
	text-indent:-.45in;}
@list l4:level5
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.";
	mso-level-tab-stop:2.0in;
	mso-level-number-position:left;
	margin-left:1.55in;
	text-indent:-.55in;}
@list l4:level6
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.";
	mso-level-tab-stop:2.25in;
	mso-level-number-position:left;
	margin-left:1.9in;
	text-indent:-.65in;}
@list l4:level7
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.";
	mso-level-tab-stop:2.75in;
	mso-level-number-position:left;
	margin-left:2.25in;
	text-indent:-.75in;}
@list l4:level8
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.";
	mso-level-tab-stop:3.0in;
	mso-level-number-position:left;
	margin-left:2.6in;
	text-indent:-.85in;}
@list l4:level9
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.%9\.";
	mso-level-tab-stop:3.5in;
	mso-level-number-position:left;
	margin-left:3.0in;
	text-indent:-1.0in;}
@list l5
	{mso-list-id:1435712892;
	mso-list-template-ids:67698719;}
@list l5:level1
	{mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;}
@list l5:level2
	{mso-level-text:"%1\.%2\.";
	mso-level-tab-stop:.75in;
	mso-level-number-position:left;
	margin-left:.55in;
	text-indent:-.3in;}
@list l5:level3
	{mso-level-text:"%1\.%2\.%3\.";
	mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	margin-left:.85in;
	text-indent:-.35in;}
@list l5:level4
	{mso-level-text:"%1\.%2\.%3\.%4\.";
	mso-level-tab-stop:1.5in;
	mso-level-number-position:left;
	margin-left:1.2in;
	text-indent:-.45in;}
@list l5:level5
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.";
	mso-level-tab-stop:2.0in;
	mso-level-number-position:left;
	margin-left:1.55in;
	text-indent:-.55in;}
@list l5:level6
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.";
	mso-level-tab-stop:2.25in;
	mso-level-number-position:left;
	margin-left:1.9in;
	text-indent:-.65in;}
@list l5:level7
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.";
	mso-level-tab-stop:2.75in;
	mso-level-number-position:left;
	margin-left:2.25in;
	text-indent:-.75in;}
@list l5:level8
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.";
	mso-level-tab-stop:3.0in;
	mso-level-number-position:left;
	margin-left:2.6in;
	text-indent:-.85in;}
@list l5:level9
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.%9\.";
	mso-level-tab-stop:3.5in;
	mso-level-number-position:left;
	margin-left:3.0in;
	text-indent:-1.0in;}
@list l6
	{mso-list-id:1739207691;
	mso-list-template-ids:-1750713120;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l7
	{mso-list-id:1804039238;
	mso-list-template-ids:67698719;
	mso-list-style-id:1064764798;}
@list l7:level1
	{mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;}
@list l7:level2
	{mso-level-text:"%1\.%2\.";
	mso-level-tab-stop:.75in;
	mso-level-number-position:left;
	margin-left:.55in;
	text-indent:-.3in;}
@list l7:level3
	{mso-level-text:"%1\.%2\.%3\.";
	mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	margin-left:.85in;
	text-indent:-.35in;}
@list l7:level4
	{mso-level-text:"%1\.%2\.%3\.%4\.";
	mso-level-tab-stop:1.5in;
	mso-level-number-position:left;
	margin-left:1.2in;
	text-indent:-.45in;}
@list l7:level5
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.";
	mso-level-tab-stop:2.0in;
	mso-level-number-position:left;
	margin-left:1.55in;
	text-indent:-.55in;}
@list l7:level6
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.";
	mso-level-tab-stop:2.25in;
	mso-level-number-position:left;
	margin-left:1.9in;
	text-indent:-.65in;}
@list l7:level7
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.";
	mso-level-tab-stop:2.75in;
	mso-level-number-position:left;
	margin-left:2.25in;
	text-indent:-.75in;}
@list l7:level8
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.";
	mso-level-tab-stop:3.0in;
	mso-level-number-position:left;
	margin-left:2.6in;
	text-indent:-.85in;}
@list l7:level9
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.%9\.";
	mso-level-tab-stop:3.5in;
	mso-level-number-position:left;
	margin-left:3.0in;
	text-indent:-1.0in;}
@list l8
	{mso-list-id:1909999853;
	mso-list-template-ids:7796770;}
@list l8:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l9
	{mso-list-id:1915234309;
	mso-list-template-ids:67698719;
	mso-list-style-id:1064764798;}
@list l9:level1
	{mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;}
@list l9:level2
	{mso-level-text:"%1\.%2\.";
	mso-level-tab-stop:.75in;
	mso-level-number-position:left;
	margin-left:.55in;
	text-indent:-.3in;}
@list l9:level3
	{mso-level-text:"%1\.%2\.%3\.";
	mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	margin-left:.85in;
	text-indent:-.35in;}
@list l9:level4
	{mso-level-text:"%1\.%2\.%3\.%4\.";
	mso-level-tab-stop:1.5in;
	mso-level-number-position:left;
	margin-left:1.2in;
	text-indent:-.45in;}
@list l9:level5
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.";
	mso-level-tab-stop:2.0in;
	mso-level-number-position:left;
	margin-left:1.55in;
	text-indent:-.55in;}
@list l9:level6
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.";
	mso-level-tab-stop:2.25in;
	mso-level-number-position:left;
	margin-left:1.9in;
	text-indent:-.65in;}
@list l9:level7
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.";
	mso-level-tab-stop:2.75in;
	mso-level-number-position:left;
	margin-left:2.25in;
	text-indent:-.75in;}
@list l9:level8
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.";
	mso-level-tab-stop:3.0in;
	mso-level-number-position:left;
	margin-left:2.6in;
	text-indent:-.85in;}
@list l9:level9
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.%9\.";
	mso-level-tab-stop:3.5in;
	mso-level-number-position:left;
	margin-left:3.0in;
	text-indent:-1.0in;}
@list l10
	{mso-list-id:1990204162;
	mso-list-template-ids:-1557759570;}
@list l10:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l11
	{mso-list-id:2015526071;
	mso-list-template-ids:-1390095198;}
@list l11:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l12
	{mso-list-id:2029326191;
	mso-list-template-ids:-1853168390;}
@list l12:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]-->
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h2 align=center style='text-align:center'><span style='font-weight:normal'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:102pt;
 height:101.25pt'>
 <v:imagedata src="Project%20Report-N_files/image001.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=136 height=135
src="Project%20Report-N_files/image002.jpg" v:shapes="_x0000_i1025"><![endif]></span></h2>

<h2 align=center style='text-align:center'><span style='font-size:24.0pt'>Introduction<o:p></o:p></span></h2>

<p style='text-align:justify'>Linux is a Unix-like operating system, which runs
on PC-386 computers. It was implemented first as extension to the Minix
operating system and its first versions included support for the Minix
filesystem only. The Minix filesystem contains two serious limitations: block
addresses are stored in 16 bit integers, thus the maximal filesystem size is
restricted to 64 mega bytes, and directories contain fixed-size entries and the
maximal file name is 14 characters. </p>

<h3 style='text-align:justify'><span style='font-family:"Times New Roman"'>History
of Linux filesystems<o:p></o:p></span></h3>

<p style='text-align:justify'>In its very early days, Linux was cross-developed
under the Minix operating system. It was easier to share disks between the two
systems than to design a new filesystem, so Linus Trovalds decided to implement
support for the Minix filesystem in Linux. The Minix filesystem was an
efficient and relatively bug-free piece of software. </p>

<p style='text-align:justify'>However, the restrictions in the design of the
Minix filesystem were too limiting, so people started thinking and working on
the implementation of new filesystems in Linux. In order to ease the addition
of new filesystems into the Linux kernel, a Virtual File System (VFS) layer was
developed. The VFS layer was initially written by Chris Provenzano, and later
rewritten by Linus Torvalds before it was integrated into the Linux kernel.</p>

<h3 style='text-align:justify'><o:p>&nbsp;</o:p></h3>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3 align=center style='text-align:center'><span style='font-weight:normal'><!--[if gte vml 1]><v:shape
 id="_x0000_i1026" type="#_x0000_t75" style='width:103.5pt;height:103.5pt'>
 <v:imagedata src="Project%20Report-N_files/image003.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=138 height=138
src="Project%20Report-N_files/image004.jpg" v:shapes="_x0000_i1026"><![endif]></span></h3>

<h3 align=center style='text-align:center'><span style='font-size:24.0pt;
font-family:"Times New Roman"'>The Kernel<o:p></o:p></span></h3>

<h3><o:p>&nbsp;</o:p></h3>

<h4 style='text-align:justify'><span style='font-size:16.0pt'>2.1 Basic File
System Concepts<o:p></o:p></span></h4>

<p style='text-align:justify'>Every Linux filesystem implements a basic set of
common concepts derivated from the Unix operating system files are represented
by inodes, directories are simply files containing a list of entries and devices
can be accessed by requesting I/O on special files. </p>

<h4 style='text-align:justify'>2.1.1 Inodes</h4>

<p style='text-align:justify'>Each file is represented by a structure, called
an inode. Each inode contains the description of the file: file type, access
rights, owners, timestamps, size, pointers to data blocks. The addresses of
data blocks allocated to a file are stored in its inode. When a user requests
an I/O operation on the file, the kernel code converts the current offset to a
block number, uses this number as an index in the block addresses table and reads
or writes the physical block.</p>

<h4 style='text-align:justify'>2.1.2 Directories</h4>

<p style='text-align:justify'>Directories are structured in a hierarchical
tree. Each directory can contain files and subdirectories. </p>

<p style='text-align:justify'>Directories are implemented as a special type of
files. Actually, a directory is a file containing a list of entries. Each entry
contains an inode number and a file name. When a process uses a pathname, the
kernel code searchs in the directories to find the corresponding inode number.
After the name has been converted to an inode number, the inode is loaded into
memory and is used by subsequent requests. </p>

<h4 style='text-align:justify'>2.1.3 Links</h4>

<p style='text-align:justify'>Unix filesystems implement the concept of link.
Several names can be associated with a inode. The inode contains a field
containing the number associated with the file. Adding a link simply consists
in creating a directory entry, where the inode number points to the inode, and
in incrementing the links count in the inode. When a link is deleted, i.e. when
one uses the <tt><span style='font-size:10.0pt'>rm</span></tt> command to
remove a filename, the kernel decrements the links count and deallocates the
inode if this count becomes zero. </p>

<p style='text-align:justify'>This type of link is called a hard link and can
only be used within a single filesystem: it is impossible to create
cross-filesystem hard links. Moreover, hard links can only point on files: a
directory hard link cannot be created to prevent the apparition of a cycle in
the directory tree. </p>

<p style='text-align:justify'>Another kind of links exists in most Unix
filesystems. Symbolic links are simply files which contain a filename. When the
kernel encounters a symbolic link during a pathname to inode conversion, it
replaces the name of the link by its contents, i.e. the name of the target
file, and restarts the pathname interpretation. Since a symbolic link does not
point to an inode, it is possible to create cross-filesystems symbolic links.
Symbolic links can point to any type of file, even on nonexistent files.
Symbolic links are very useful because they don't have the limitations
associated to hard links. However, they use some disk space, allocated for
their inode and their data blocks, and cause an overhead in the pathname to
inode conversion because the kernel has to restart the name interpretation when
it encounters a symbolic link. </p>

<h4 style='text-align:justify'>2.1.4 Device special files</h4>

<p style='text-align:justify'>In Unix-like operating systems, devices can be
accessed via special files. A device special file does not use any space on the
filesystem. It is only an access point to the device driver. </p>

<p style='text-align:justify'>Two types of special files exist: character and
block special files. The former allows I/O operations in character mode while
the later requires data to be written in block mode via the buffer cache
functions. When an I/O request is made on a special file, it is forwarded to a
(pseudo) device driver. A special file is referenced by a major number, which
identifies the device type, and a minor number, which identifies the unit. <a
name="section:vfs"></a></p>

<h4 style='text-align:justify'><span style='mso-bookmark:"section\:vfs"'><span
style='font-size:16.0pt'>2.2 The Virtual File System<o:p></o:p></span></span></h4>

<span style='mso-bookmark:"section\:vfs"'></span>

<h4 style='text-align:justify'>2.2.1 Principle</h4>

<p style='text-align:justify'>The Linux kernel contains a Virtual File System
layer which is used during system calls acting on files. The VFS is an
indirection layer which handles the file oriented system calls and calls the
necessary functions in the physical filesystem code to do the I/O. </p>

<p style='text-align:justify'>This indirection mechanism is frequently used in
Unix-like operating systems to ease the integration and the use of several
filesystem types.</p>

<p style='text-align:justify'>When a process issues a file oriented system
call, the kernel calls a function contained in the VFS. This function handles
the structure independent manipulations and redirects the call to a function
contained in the physical filesystem code, which is responsible for handling
the structure dependent operations. Filesystem code uses the buffer cache
functions to request I/O on devices as shown in figure. </p>

<p style='text-align:justify'><!--[if gte vml 1]><v:shape id="_x0000_i1027"
 type="#_x0000_t75" style='width:450pt;height:322.5pt'>
 <v:imagedata src="Project%20Report-N_files/image005.jpg" o:title="010"/>
</v:shape><![endif]--><![if !vml]><img width=600 height=430
src="Project%20Report-N_files/image005.jpg" v:shapes="_x0000_i1027"><![endif]><o:p></o:p></p>

<h4 style='text-align:justify'>2.2.2 The VFS structure</h4>

<p style='text-align:justify'>The VFS defines a set of functions that every
filesystem has to implement. This interface is made up of a set of operations
associated to three kinds of objects: filesystems, inodes, and open files. </p>

<p style='text-align:justify'>The VFS knows about filesystem types supported in
the kernel. It uses a table defined during the kernel configuration. Each entry
in this table describes a filesystem type: it contains the name of the
filesystem type and a pointer on a function called during the mount operation.
When a filesystem is to be mounted, the appropriate mount function is called.
This function is responsible for reading the superblock from the disk,
initializing its internal variables, and returning a mounted filesystem
descriptor to the VFS. After the filesystem is mounted, the VFS functions can
use this descriptor to access the physical filesystem routines. </p>

<p style='text-align:justify'>A mounted filesystem descriptor contains several
kinds of data: informations that are common to every filesystem types, pointers
to functions provided by the physical filesystem kernel code, and private data
maintained by the physical filesystem code. The function pointers contained in
the filesystem descriptors allow the VFS to access the filesystem internal
routines. </p>

<p style='text-align:justify'><!--[if gte vml 1]><v:shape id="_x0000_i1028"
 type="#_x0000_t75" style='width:423pt;height:215.25pt'>
 <v:imagedata src="Project%20Report-N_files/image006.jpg" o:title="010"/>
</v:shape><![endif]--><![if !vml]><img width=564 height=287
src="Project%20Report-N_files/image006.jpg" v:shapes="_x0000_i1028"><![endif]><o:p></o:p></p>

<p style='text-align:justify'>Two other types of descriptors are used by the
VFS: an inode descriptor and an open file descriptor. Each descriptor contains
informations related to files in use and a set of operations provided by the
physical filesystem code. While the inode descriptor contains pointers to
functions that can be used to act on any file (e.g. <tt><span style='font-size:
10.0pt'>create</span></tt>, <tt><span style='font-size:10.0pt'>unlink</span></tt>),
the file descriptors contains pointer to functions which can only act on open
files (e.g. <tt><span style='font-size:10.0pt'>read</span></tt>, <tt><span
style='font-size:10.0pt'>write</span></tt>). <a name="section:ext2fs"></a></p>

<p style='text-align:justify'><span style='mso-bookmark:"section\:ext2fs"'>The
role of the VFS is: </span></p>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     text-align:justify;mso-list:l12 level1 lfo9;tab-stops:list .5in'><span
     style='mso-bookmark:"section\:ext2fs"'>Keep track of available filesystem
     types. </span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     text-align:justify;mso-list:l12 level1 lfo9;tab-stops:list .5in'><span
     style='mso-bookmark:"section\:ext2fs"'>Associate (and disassociate)
     devices with instances of the appropriate filesystem. </span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     text-align:justify;mso-list:l12 level1 lfo9;tab-stops:list .5in'><span
     style='mso-bookmark:"section\:ext2fs"'>Do any reasonable generic
     processing for operations involving files. </span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     text-align:justify;mso-list:l12 level1 lfo9;tab-stops:list .5in'><span
     style='mso-bookmark:"section\:ext2fs"'>When filesystem-specific operations
     become necessary, vector them to the filesystem in charge of the file,
     directory, or inode in question. </span></li>
</ul>

<p class=MsoNormal style='text-align:justify'><span style='mso-bookmark:"section\:ext2fs"'>The
interaction between the VFS and specific filesystem types occurs through two
main data structures, the </span><span style='mso-bookmark:"section\:ext2fs"'><tt><span
style='font-size:10.0pt'>super_block</span></tt> structure and the </span><span
style='mso-bookmark:"section\:ext2fs"'><tt><span style='font-size:10.0pt'>inode</span></tt>
structure, and their associated data structures, including </span><span
style='mso-bookmark:"section\:ext2fs"'><tt><span style='font-size:10.0pt'>super_operations</span></tt>,
</span><span style='mso-bookmark:"section\:ext2fs"'><tt><span style='font-size:
10.0pt'>inode_operations</span></tt>, </span><span style='mso-bookmark:"section\:ext2fs"'><tt><span
style='font-size:10.0pt'>file_operations</span></tt>, and others, which are
kept in the include file </span><span style='mso-bookmark:"section\:ext2fs"'><tt><span
style='font-size:10.0pt'>&lt;linux/fs.h&gt;</span></tt>. </span></p>

<p style='text-align:justify'><span style='mso-bookmark:"section\:ext2fs"'>Therefore,
the role of a specific filesystem code is to provide a superblock for each
filesystem mounted and a unique inode for each file on the filesystem, and to
provide code to carry out actions specific to filesystems and files that are
requested by system calls and sorted out by the VFS. </span></p>

<p style='text-align:justify'><span style='mso-bookmark:"section\:ext2fs"'><o:p>&nbsp;</o:p></span></p>

<span style='mso-bookmark:"section\:ext2fs"'></span>

<h2><span style='font-size:16.0pt'>2.3 Writing a Simple File System<o:p></o:p></span></h2>

<p>The Linux VFS supports multiple file systems. The kernel does most of the
work while the file system specific tasks are delegated to the individual file
systems through the handlers. Instead of calling the functions directly the
kernel uses various Operation Tables, which are a collection of handlers for
each operation (these are actually structures of function pointers for each
handlers/callbacks). The kernel calls the handler present in the table for the
operation. This enables different file systems to register different handlers.
This also enables the common tasks to be done before calling the handlers. This
reduces the burden on the handlers which can then focus on the operation
specific to that file system.<br>
<br>
File systems are identified by their names. The supported file systems can be
seen using 'cat /proc/filesystems'. The first step is to register the file
system with the kernel. Since we are using a kernel module, the file system
registration is done during the module initialization. This registers handlers
which will be called to fill the super block structure while mounting, a
handler to do the cleanup during unmounting the file system. There are other
handlers but these two are essential.<br>
<br>
The super block operations are set at the time of mounting. The operation
tables for inodes and files are set when the inode is opened. The first step
before opening an inode is lookup. The inode of a file is looked up by calling
the lookup handler of the parent inode. But what about the root-most inode of
the new file system? This has to be allocated at the time of mounting i.e.,
during the super block initialization.<br>
<br>
Once the operation tables are set on the data structures, the kernel calls the
handlers depending on the operation.<br>
<br>
<b style='mso-bidi-font-weight:normal'><span style='font-size:14.0pt'>2.3.1<span
style='mso-bidi-font-weight:bold'>. Data Structures</span></span></b><br>
<br>
This is a brief description about the data structures used in implementing our
file system.<br>
<br>
<b>a. File System Type (struct file_system_type)</b><br>
Definition found in <i>include/linux/fs.h</i><br>
<br>
This structure is used to register the filesystem with the kernel. This data
structure is used by the kernel at the time of mounting a file system. We have
to fill the 'name' field with the name of our file system (example &quot;emailfs&quot;)
and the handlers get_sb and kill_sb to allocate and release the super block
objects.<br>
<br>
<b>b. Super Block (struct super_block)</b><br>
Definition found in <i>include/linux/fs.h</i><br>
<br>
This stores the information about the mounted file system. The important fields
to be filled are the operation table (s_ops field) and the root dentry
(s_root). At the time of mounting a file system, the kernel calls the get_sb
field of the file_system_type object (it identifies the correct
file_system_type object based on the file system name) to get a super block
object.<br>
<br>
<b>c. Super Block Operations (struct super_operations)</b><br>
Definition found in <i>include/linux/fs.h</i><br>
<br>
Super block operations table.<br>
<br>
<b>d. Inode (struct inode)</b><br>
Definition found in <i>include/linux/fs.h</i><br>
<br>
Inode object is the kernel representation of the low level file. We return the
dentry of the root of our file system. We have to attach a proper inode also to
the dentry.<br>
<br>
This structure has two operation tables i_op, i_fop i.e., inode operations and
file operations respectively. We will implement one operation in the
inode_operations - lookup.<br>
<br>
This is called when the kernel is resolving a path. The kernel starts from the
ancestor (this can be the current working directory for relative paths or the
root most directory for the absolute paths) and gets the dentry (also the
inode) of a name component of the path from its parent. This is achieved by
calling inode_operations.lookup on the inode of the parent entry.<br>
<br>
For example, when the kernel is resolving /parentdir/subdir, the lookup
operation reaches the root most inode of the file system. This was already
allocated during the super block initialization and stored in the s_root field.
To resolve the 'parentdir' under the root most inode, the kernel creates a new
dentry object, sets the name as 'parentdir' and calls lookup handler on inode
of the root most inode. The handler is supposed to attach the inode to the
dentry using d_add and return NULL if it was successful or an error code
otherwise. Similarly, the lookup for 'subdir' is done by the parentdir inode.
The dentry cache and the inode cache saves repeated lookups and boosts the
performance.<br>
<br>
It is important for us to implement the lookup callback. This will be called by
the open system call.<br>
<br>
<b>e. Inode Operations (struct inode_operations)<br>
</b>Definition found in <i>include/linux/fs.h</i><br>
<br>
This is the inode operations table with each field corresponding to a function
pointer to handle the task. It has fields like mkdir, lookup etc. We are
interested in lookup.<br>
<br>
<b>f. Address Space Operations (struct address_space_operations)</b><br>
Definition found in <i>include/linux/fs.h</i><br>
<br>
Address space operations table.<br>
<br>
<b>g. DEntry (struct dentry)</b><br>
Definition found in <i>include/linux/dcache.h</i><br>
<br>
The kernel uses dentries to represent the file system structure. dentries point
to inode objects. This has pointers to store the parent-child relationship of
the files. Inodes and files do not store any information about the hierarchy.<br>
<br>
<b>h. File (struct file)</b><br>
Definition found in <i>include/linux/fs.h</i><br>
<br>
File object is used to store the process's information about the file. We dont
have to fill any fields of the files directly. The kernel takes care of filling
the proper fields but we have to implement the file operation callbacks. We
register the file operation table when we return the inode object during
lookup. The file operations are copied from the i_fop field of the inode object
to the file object by the kernel.<br>
We will implement readdir in case of directories (while returning the inode, we
have to set the file operation table based on the type of the file) and
read/write in the case of regular files. We will have two file operation tables
one for directories and the other for regular files.<br>
<br>
The relationship between files, dentries and objects is like this:</p>

<p class=MsoNormal style='margin-top:5.0pt;margin-right:0in;margin-bottom:5.0pt;
margin-left:0in;mso-layout-grid-align:none;text-autospace:none'>File ---&gt;
DEntry ---&gt; Inode<br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><br>
The following figure shows the important relationships between various VFS data
structures. It does not show all the relationships though. Note that super
block structure has a list of all open file objects, a list of dirty inodes and
another list of locked inodes of the file system. Also the lists used for
cache, lru and free lists are not shown.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Fig missing</p>

<p class=MsoNormal><br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></p>

<p class=MsoNormal><b>i. File Operations (struct file_operations)</b><br>
<span style='mso-spacerun:yes'>  </span>Definition found in <i>include/linux/fs.h</i><br>
<br>
This is the file operations table with each field corresponding to a function
pointer to handle the task. It has fields like read, write, readdir, llseek
etc.<br>
<br>
All these structures have fields used by the kernel in maintaining internal
data structures like lists and hash tables etc. So, we cannot use local/global
obects. Kernel allocates the object and passes it to our functions so that we
can fill the required fields. If we have to allocate the objects, we need to
use the corresponding allocator functions.<br>
<!--[if gte vml 1]><v:shape id="_x0000_i1029" type="#_x0000_t75" style='width:102pt;
 height:102pt'>
 <v:imagedata src="Project%20Report-N_files/image007.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=136 height=136
src="Project%20Report-N_files/image008.jpg" v:shapes="_x0000_i1029"><![endif]><br
style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></p>

<p class=MsoNormal align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><span style='font-size:24.0pt'>The Daemon<o:p></o:p></span></b></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><b><span style='font-size:13.5pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:13.5pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:13.5pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:13.5pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal align=center style='text-align:center'><b><span
style='font-size:13.5pt'><!--[if gte vml 1]><v:shape id="_x0000_i1030" type="#_x0000_t75"
 style='width:102.75pt;height:102pt'>
 <v:imagedata src="Project%20Report-N_files/image009.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=137 height=136
src="Project%20Report-N_files/image010.jpg" v:shapes="_x0000_i1030"><![endif]><o:p></o:p></span></b></p>

<p class=MsoNormal align=center style='text-align:center'><b><span
style='font-size:24.0pt'>Communication Between The Kernel And The Daemon<o:p></o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:13.5pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><b
style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1031" type="#_x0000_t75" style='width:6in;height:357.75pt'>
 <v:imagedata src="Project%20Report-N_files/image011.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=576 height=477
src="Project%20Report-N_files/image012.jpg" v:shapes="_x0000_i1031"><![endif]><o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><b
style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt;color:black'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><b
style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt;color:black'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><b
style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt;color:black'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><b
style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt;color:black'>4.1
Possible Methods<o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
style='color:black'>There are several different methods for reading kernel
routing table information, updating kernel routing tables, and for looking up
interfaces. <o:p></o:p></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:14.0pt;color:black'>ioctl<o:p></o:p></span></b></p>

<p class=MsoNormal><span style='color:black'>The ioctl method is a very
traditional way for reading or writing kernel information. ioctl can be used
for looking up interfaces and for modifying interface addresses, flags, mtu
settings and other types of information. Also, ioctl can insert and delete
kernel routing table entries. It will soon be available on almost any platform
which zebra supports, but it is a little bit ugly thus far, so if a better
method is supported by the kernel, zebra will use that. <o:p></o:p></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:14.0pt;color:black'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:14.0pt;color:black'>sysctl <o:p></o:p></span></b></p>

<p class=MsoNormal><span style='color:black'>sysctl can lookup kernel
information using MIB (Management Information Base) syntax. Normally, it only
provides a way of getting information from the kernel. So one would usually
want to change kernel information using another method such as ioctl. <o:p></o:p></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:14.0pt;color:black'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:14.0pt;color:black'>proc filesystem <o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
style='color:black'>In Linux there is an additional mechanism for the kernel
and kernel modules to send information to processes --- the </span><span
style='font-size:10.0pt;mso-bidi-font-size:12.0pt;font-family:"Courier New";
color:black'>/proc</span><span style='color:black'> file system. Originally
designed to allow easy access to information about processes (hence the name),
it is now used by every bit of the kernel which has something interesting to
report, such as </span><span style='font-size:10.0pt;mso-bidi-font-size:12.0pt;
font-family:"Courier New";color:black'>/proc/modules</span><span
style='color:black'> which has the list of modules and </span><span
style='font-size:10.0pt;mso-bidi-font-size:12.0pt;font-family:"Courier New";
color:black'>/proc/meminfo</span><span style='color:black'> which has memory
usage statistics.<o:p></o:p></span></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
style='color:black'>The method to use the proc file system is very similar to
the one used with device drivers --- you create a structure with all the
information needed for the </span><span style='font-size:10.0pt;mso-bidi-font-size:
12.0pt;font-family:"Courier New";color:black'>/proc</span><span
style='color:black'> file, including pointers to any handler functions. Then, </span><span
style='font-size:10.0pt;mso-bidi-font-size:12.0pt;font-family:"Courier New";
color:black'>init_module</span><span style='color:black'> registers the
structure with the kernel and </span><span style='font-size:10.0pt;mso-bidi-font-size:
12.0pt;font-family:"Courier New";color:black'>cleanup_module</span><span
style='color:black'> unregisters it.<o:p></o:p></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:14.0pt;color:black'>netlink <o:p></o:p></span></b></p>

<p class=MsoNormal><span style='color:black'>On recent Linux kernels (2.0.x and
2.2.x), there is a kernel/user communication support called netlink. It makes
asynchronous communication between kernel and Zebra possible, similar to a
routing socket on BSD systems. <o:p></o:p></span></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
style='color:black'>Before you use this feature, be sure to select (in kernel
configuration) the kernel/netlink support option 'Kernel/User network link
driver' and 'Routing messages'. <o:p></o:p></span></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
style='color:black'>Today, the /dev/route special device file is obsolete.
Netlink communication is done by reading/writing over netlink socket. <o:p></o:p></span></p>

<p class=MsoNormal><b><span style='font-size:16.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:16.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:16.0pt'>4.2 </span></b><b
style='mso-bidi-font-weight:normal'><span lang=EN style='font-size:16.0pt;
mso-ansi-language:EN'>Netlink Socket <o:p></o:p></span></b></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Netlink is used to transfer information between kernel
modules and user space processes, it provides kernel/user space bidirectional
communication links. It consists of a standard sockets based interface for user
processes and an internal kernel API for kernel modules.<b style='mso-bidi-font-weight:
normal'><span lang=EN style='font-size:16.0pt;mso-ansi-language:EN'><o:p></o:p></span></b></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span lang=EN
style='font-size:14.0pt;mso-ansi-language:EN'>4.2.1 Why and How to Use Netlink
Socket<o:p></o:p></span></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span lang=EN
style='font-size:14.0pt;mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'>Netlink socket is
a special IPC used for transferring information between kernel and user-space
processes. It provides a full-duplex communication link between the two by way
of standard socket APIs for user-space processes and a special kernel API for
kernel modules. <o:p></o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'>Netlink sockets
is a bidirectional, versatile method to pass data between kernel and user
space.<a name=N0x850ca10.0x8573a08></a> Due to the complexity of developing and
maintaining the kernel, only the most essential and performance-critical code
are placed in the kernel. Other things, such as GUI, management and control
code, typically are programmed as user-space applications. This practice of splitting
the implementation of certain features between kernel and user space is quite
common in Linux.<o:p></o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'>Why should we use
netlink instead of system calls, ioctls or proc filesystems for communication
between user and kernel worlds? It is a nontrivial task to add system calls,
ioctls or proc files for new features; we risk polluting the kernel and
damaging the stability of the system. Netlink socket is simple, though: only a
constant, the protocol type, needs to be added to netlink.h. Then, the kernel
module and application can talk using socket-style APIs immediately.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Netlink is asynchronous because,
as with any other socket API, it provides a socket queue to smooth the burst of
messages. The system call for sending a netlink message queues the message to
the receiver's netlink queue and then invokes the receiver's reception handler.
The receiver, within the reception handler's context, can decide whether to
process the message immediately or leave the message in the queue and process
it later in a different context. Unlike netlink, system calls require
synchronous processing. Therefore, if we use a system call to pass a message
from user space to the kernel, the kernel scheduling granularity may be
affected if the time to process that message is long.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>The code implementing a system
call in the kernel is linked statically to the kernel in compilation time;
thus, it is not appropriate to include system call code in a loadable module,
which is the case for most device drivers. With netlink socket, no compilation
time dependency exists between the netlink core of Linux kernel and the netlink
application living in loadable kernel modules.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Netlink socket supports
multicast, which is another benefit over system calls, ioctls and proc. One
process can multicast a message to a netlink group address, and any number of
other processes can listen to that group address. This provides a near-perfect
mechanism for event distribution from kernel to user space.<o:p></o:p></span></p>

<h2><a name=N0x850ca10.0x8573eac></a><span lang=EN style='font-size:16.0pt;
mso-ansi-language:EN'>4.3 User-space Netlink Socket APIs<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>The standard socket
APIs-socket(), sendmsg(), recvmsg() and close()-can be used by user-space
applications to access netlink socket. You can consult the man pages for
detailed definitions of these APIs. Here, we discuss how to choose parameters
for these APIs only in the context of netlink socket. The APIs should be
familiar to anyone who has written an ordinary network application using TCP/IP
sockets.<o:p></o:p></span></p>

<p><b style='mso-bidi-font-weight:normal'><span lang=EN style='font-size:14.0pt;
mso-ansi-language:EN'>4.3.1 socket()<o:p></o:p></span></b></p>

<p><span lang=EN style='mso-ansi-language:EN'>To create a socket with socket(),
enter:<o:p></o:p></span></p>

<p class=MsoNormal><tt><i style='mso-bidi-font-style:normal'><span lang=EN
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;font-family:"Times New Roman";
mso-ansi-language:EN'>int socket(int domain, int type, int protocol)<o:p></o:p></span></i></tt></p>

<p><span lang=EN style='mso-ansi-language:EN'>The socket domain (address
family) is AF_NETLINK, and the type of socket is either SOCK_RAW or SOCK_DGRAM,
because netlink is a datagram-oriented service.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>The protocol (protocol type)
selects for which netlink feature the socket is used. The following are some
predefined netlink protocol types: NETLINK_ROUTE, NETLINK_FIREWALL,
NETLINK_ARPD, NETLINK_ROUTE6 and NETLINK_IP6_FW. You also can add your own
netlink protocol type easily.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Up to 32 multicast groups can be
defined for each netlink protocol type. Each multicast group is represented by
a bit mask, 1&lt;&lt;i, where 0&lt;=i&lt;=31. This is extremely useful when a
group of processes and the kernel process coordinate to implement the same
feature-sending multicast netlink messages can reduce the number of system
calls used and alleviate applications from the burden of maintaining the
multicast group membership.<o:p></o:p></span></p>

<h2><a name=N0x850ca10.0x857400c></a><span lang=EN style='font-size:14.0pt;
mso-ansi-language:EN'>4.3.2 bind()<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>As for a TCP/IP socket, the
netlink bind() API associates a local (source) socket address with the opened
socket. The netlink address structure is as follows:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'>struct sockaddr_nl<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>{<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>sa_family_t<span style='mso-spacerun:yes'>    </span>nl_family;<span style='mso-spacerun:yes'>  </span>/* AF_NETLINK<span style='mso-spacerun:yes'>   </span>*/<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>unsigned short nl_pad;<span style='mso-spacerun:yes'>     </span>/* zero<span style='mso-spacerun:yes'>         </span>*/<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>__u32<span style='mso-spacerun:yes'>          </span>nl_pid;<span style='mso-spacerun:yes'>     </span>/* process pid */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>__u32<span style='mso-spacerun:yes'>          </span>nl_groups;<span style='mso-spacerun:yes'>  </span>/* mcast groups mask */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>} nladdr;<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>When used with bind(), the nl_pid
field of the sockaddr_nl can be filled with the calling process' own pid. The
nl_pid serves here as the local address of this netlink socket. The application
is responsible for picking a unique 32-bit integer to fill in nl_pid:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'>NL_PID Formula 1:<span style='mso-spacerun:yes'>  </span>nl_pid = getpid();<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Formula 1 uses the process ID of
the application as nl_pid, which is a natural choice if, for the given netlink
protocol type, only one netlink socket is needed for the process.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>In scenarios where different
threads of the same process want to have different netlink sockets opened under
the same netlink protocol, Formula 2 can be used to generate the nl_pid:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>NL_PID Formula 2: pthread_self() &lt;&lt; 16 | getpid();<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><span lang=EN style='mso-ansi-language:EN'>In this way, different pthreads
of the same process each can have their own netlink socket for the same netlink
protocol type. In fact, even within a single pthread it's possible to create
multiple netlink sockets for the same protocol type. Developers need to be more
creative, however, in generating a unique nl_pid, and we don't consider this to
be a normal-use case.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>If the application wants to
receive netlink messages of the protocol type that are destined for certain
multicast groups, the bitmasks of all the interested multicast groups should be
ORed together to form the nl_groups field of sockaddr_nl. Otherwise, nl_groups
should be zeroed out so the application receives only the unicast netlink
message of the protocol type destined for the application. After filling in the
nladdr, do the bind as follows:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>bind(fd, (struct sockaddr*)&amp;nladdr, sizeof(nladdr));<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><a name=N0x850ca10.0x857421c></a><b style='mso-bidi-font-weight:normal'><span
lang=EN style='font-size:14.0pt;mso-ansi-language:EN'>4.3.3 sendmsg()<o:p></o:p></span></b></p>

<p><span lang=EN style='mso-ansi-language:EN'>In order to send a netlink
message to the kernel or other user-space processes, another struct sockaddr_nl
nladdr needs to be supplied as the destination address, the same as sending a
UDP packet with sendmsg(). If the message is destined for the kernel, both
nl_pid and nl_groups should be supplied with 0.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>If the message is a unicast
message destined for another process, the nl_pid is the other process' pid and
nl_groups is 0, assuming nlpid Formula 1 is used in the system.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>If the message is a multicast
message destined for one or multiple multicast groups, the bitmasks of all the
destination multicast groups should be ORed together to form the nl_groups
field. We then can supply the netlink address to the struct msghdr msg for the
sendmsg() API, as follows:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct msghdr msg;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_name = (void *)&amp;(nladdr);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_namelen = sizeof(nladdr);<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>The netlink socket requires its
own message header as well. This is for providing a common ground for netlink
messages of all protocol types.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Because the Linux kernel netlink
core assumes the existence of the following header in each netlink message, an
application must supply this header in each netlink message it sends:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct nlmsghdr<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>{<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>__u32 nlmsg_len;<span style='mso-spacerun:yes'>   </span>/* Length of message */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>__u16 nlmsg_type;<span style='mso-spacerun:yes'>  </span>/* Message type*/<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>__u16 nlmsg_flags; /* Additional flags */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>__u32 nlmsg_seq;<span style='mso-spacerun:yes'>   </span>/* Sequence number */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>__u32 nlmsg_pid;<span style='mso-spacerun:yes'>   </span>/* Sending process PID */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>};<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><span lang=EN style='mso-ansi-language:EN'>nlmsg_len has to be completed
with the total length of the netlink message, including the header, and is
required by netlink core. nlmsg_type can be used by applications and is an
opaque value to netlink core. nlmsg_flags is used to give additional control to
a message; it is read and updated by netlink core. nlmsg_seq and nlmsg_pid are
used by applications to track the message, and they are opaque to netlink core
as well.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>A netlink message thus consists
of nlmsghdr and the message payload. Once a message has been entered, it enters
a buffer pointed to by the nlh pointer. We also can send the message to the
struct msghdr msg:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct iovec iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>iov.iov_base = (void *)nlh;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>iov.iov_len = nlh-&gt;nlmsg_len;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_iov = &amp;iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_iovlen = 1;<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><span lang=EN style='mso-ansi-language:EN'>After the above steps, a call to
sendmsg() kicks out the netlink message:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'>sendmsg(fd, &amp;msg, 0);<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><a name=N0x850ca10.0x8574484></a><b style='mso-bidi-font-weight:normal'><span
lang=EN style='font-size:14.0pt;mso-ansi-language:EN'>4.3.4 recvmsg()<o:p></o:p></span></b></p>

<p><span lang=EN style='mso-ansi-language:EN'>A receiving application needs to
allocate a buffer large enough to hold netlink message headers and message
payloads. It then fills the struct msghdr msg as shown below and uses the
standard recvmsg() to receive the netlink message, assuming the buffer is
pointed to by nlh:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct sockaddr_nl nladdr;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct msghdr msg;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct iovec iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>iov.iov_base = (void *)nlh;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>iov.iov_len = MAX_NL_MSG_LEN;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_name = (void *)&amp;(nladdr);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_namelen = sizeof(nladdr);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_iov = &amp;iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>msg.msg_iovlen = 1;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>recvmsg(fd, &amp;msg, 0);<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>After the message has been
received correctly, the nlh should point to the header of the just-received
netlink message. nladdr should hold the destination address of the received
message, which consists of the pid and the multicast groups to which the
message is sent. And, the macro NLMSG_DATA(nlh), defined in netlink.h, returns
a pointer to the payload of the netlink message. A call to close(fd) closes the
netlink socket identified by file descriptor fd.<o:p></o:p></span></p>

<h2><a name=N0x850ca10.0x8574560></a><span lang=EN style='font-size:16.0pt;
mso-ansi-language:EN'>4.4 Kernel-Space Netlink APIs<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>The kernel-space netlink API is
supported by the netlink core in the kernel, net/core/af_netlink.c. From the
kernel side, the API is different from the user-space API. The API can be used
by kernel modules to access the netlink socket and to communicate with user-space
applications. Unless you leverage the existing netlink socket protocol types,
you need to add your own protocol type by adding a constant to netlink.h. For
example, we can add a netlink protocol type for testing purposes by inserting
this line into netlink.h:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'>#define NETLINK_TEST<span style='mso-spacerun:yes'>  </span>17<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><span lang=EN style='mso-ansi-language:EN'>Afterward, you can reference the
added protocol type anywhere in the Linux kernel.<o:p></o:p></span></p>

<p><b style='mso-bidi-font-weight:normal'><span lang=EN style='font-size:14.0pt;
mso-ansi-language:EN'>4.4.1 Socket Creation<o:p></o:p></span></b></p>

<p><span lang=EN style='mso-ansi-language:EN'>In user space, we call socket()
to create a netlink socket, but in kernel space, we call the following API:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct sock *<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>netlink_kernel_create(int unit, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>           </span>void (*input)(struct sock *sk, int len));<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><span lang=EN style='mso-ansi-language:EN'>The parameter unit is, in fact,
the netlink protocol type, such as NETLINK_TEST. The function pointer, input,
is a callback function invoked when a message arrives at this netlink socket.<o:p></o:p></span></p>

<p><b style='mso-bidi-font-weight:normal'><span lang=EN style='font-size:14.0pt;
mso-ansi-language:EN'>4.4.2 Receiving user-space Messages<o:p></o:p></span></b></p>

<p><span lang=EN style='mso-ansi-language:EN'>After the kernel has created a
netlink socket for protocol NETLINK_TEST, whenever user space sends a netlink
message of the NETLINK_TEST protocol type to the kernel, the callback function,
input(), which is registered by netlink_kernel_create(), is invoked. The
following is an example implementation of the callback function input:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void input (struct sock *sk, int len)<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>{<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> struct sk_buff *skb;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> struct nlmsghdr *nlh = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> u8 *payload = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> while ((skb = skb_dequeue(&amp;sk-&gt;receive_queue)) <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>       </span>!= NULL) {<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* process netlink message pointed by skb-&gt;data */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh = (struct nlmsghdr *)skb-&gt;data;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> payload = NLMSG_DATA(nlh);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* process netlink message with header pointed by <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>* nlh and payload pointed by payload<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>*/<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> }<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>}<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>This input() function is called
in the context of the sendmsg() system call invoked by the sending process. It
is okay to process the netlink message inside input() if it's fast. When the
processing of netlink message takes a long time, however, we want to keep it
out of input() to avoid blocking other system calls from entering the kernel.
Instead, we can use a dedicated kernel thread to perform the following steps
indefinitely. Use </span><tt><span lang=EN style='font-size:10.0pt;mso-ansi-language:
EN'>skb = skb_recv_datagram(nl_sk)</span></tt><span lang=EN style='mso-ansi-language:
EN'> where </span><tt><span lang=EN style='font-size:10.0pt;mso-ansi-language:
EN'>nl_sk</span></tt><span lang=EN style='mso-ansi-language:EN'> is the netlink
socket returned by netlink_kernel_create(). Then, process the netlink message
pointed to by skb-&gt;data.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>This kernel thread sleeps when
there is no netlink message in nl_sk. Thus, inside the callback function
input(), we need to wake up only the sleeping kernel thread, like this:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void input (struct sock *sk, int len)<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>{<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>wake_up_interruptible(sk-&gt;sleep);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>}<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>This is a more scalable
communication model between user space and kernel. It also improves the
granularity of context switches.<o:p></o:p></span></p>

<h2><a name=N0x850ca10.0x85d2bd8></a><span lang=EN style='font-size:14.0pt;
mso-ansi-language:EN'>4.4.3 Sending Netlink Messages from the Kernel<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>Just as in user space, the source
netlink address and destination netlink address need to be set when sending a
netlink message. Assuming the socket buffer holding the netlink message to be
sent is struct sk_buff *skb, the local address can be set with:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>NETLINK_CB(skb).groups = local_groups;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>NETLINK_CB(skb).pid = 0;<span style='mso-spacerun:yes'>   </span>/* from kernel */<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>The destination address can be
set like this:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>NETLINK_CB(skb).dst_groups = dst_groups;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>NETLINK_CB(skb).dst_pid = dst_pid;<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Such information is not stored in
skb-&gt;data. Rather, it is stored in the netlink control block of the socket
buffer, skb.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>To send a unicast message, use:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>int <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>netlink_unicast(struct sock *ssk, struct sk_buff <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>                </span>*skb, u32 pid, int nonblock);<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><a name=N0x850ca10.0x85d2d64></a><span lang=EN style='mso-ansi-language:
EN'>where </span><tt><span lang=EN style='font-size:10.0pt;mso-ansi-language:
EN'>ssk</span></tt><span lang=EN style='mso-ansi-language:EN'> is the netlink
socket returned by netlink_kernel_create(), </span><tt><span lang=EN
style='font-size:10.0pt;mso-ansi-language:EN'>skb-&gt;data</span></tt><span
lang=EN style='mso-ansi-language:EN'> points to the netlink message to be sent
and </span><tt><span lang=EN style='font-size:10.0pt;mso-ansi-language:EN'>pid</span></tt><span
lang=EN style='mso-ansi-language:EN'> is the receiving application's pid,
assuming NLPID Formula 1 is used. </span><tt><span lang=EN style='font-size:
10.0pt;mso-ansi-language:EN'>nonblock</span></tt><span lang=EN
style='mso-ansi-language:EN'> indicates whether the API should block when the receiving
buffer is unavailable or immediately return a failure.<o:p></o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>You also can send a multicast
message. The following API delivers a netlink message to both the process
specified by pid and the multicast groups specified by group:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>netlink_broadcast(struct sock *ssk, struct sk_buff <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>         </span>*skb, u32 pid, u32 group, int allocation);<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><a name=N0x850ca10.0x85d2ef0></a><tt><span lang=EN style='font-size:10.0pt;
mso-ansi-language:EN'>group</span></tt><span lang=EN style='mso-ansi-language:
EN'> is the ORed bitmasks of all the receiving multicast groups. </span><tt><span
lang=EN style='font-size:10.0pt;mso-ansi-language:EN'>allocation</span></tt><span
lang=EN style='mso-ansi-language:EN'> is the kernel memory allocation type.
Typically, GFP_ATOMIC is used if from interrupt context; GFP_KERNEL if
otherwise. This is due to the fact that the API may need to allocate one or
many socket buffers to clone the multicast message.<o:p></o:p></span></p>

<h2><a name=N0x850ca10.0x85d2fcc></a><span lang=EN style='font-size:14.0pt;
mso-ansi-language:EN'>4.4.4 Closing a Netlink Socket from the Kernel<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>Given the struct sock *nl_sk
returned by netlink_kernel_create(), we can call the following kernel API to
close the netlink socket in the kernel:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>sock_release(nl_sk-&gt;socket);<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p><span lang=EN style='mso-ansi-language:EN'>So far, we have shown only the
bare minimum code framework to illustrate the concept of netlink programming.
We now will use our NETLINK_TEST netlink protocol type and assume it already
has been added to the kernel header file. The kernel module code listed here
contains only the netlink-relevant part, so it should be inserted into a
complete kernel module skeleton, which you can find from many other reference
sources.<o:p></o:p></span></p>

<h2><a name=N0x850ca10.0x85d30a8></a><span lang=EN style='font-size:16.0pt;
mso-ansi-language:EN'>4.5 Unicast Communication between Kernel and</span><span
lang=EN style='mso-ansi-language:EN'> </span><span lang=EN style='font-size:
16.0pt;mso-ansi-language:EN'>Application<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>In this example, a user-space
process sends a netlink message to the kernel module, and the kernel module
echoes the message back to the sending process. Here is the user-space code:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>#include &lt;sys/socket.h&gt;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>#include &lt;linux/netlink.h&gt;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>#define MAX_PAYLOAD 1024<span style='mso-spacerun:yes'>  </span>/* maximum payload size*/<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct sockaddr_nl src_addr, dest_addr;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct nlmsghdr *nlh = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct iovec iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>int sock_fd;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void main() {<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> sock_fd = socket(PF_NETLINK, SOCK_RAW,NETLINK_TEST);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> memset(&amp;src_addr, 0, sizeof(src_addr));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> src__addr.nl_family = AF_NETLINK;<span style='mso-spacerun:yes'>      </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'> </span>src_addr.nl_pid = getpid();<span style='mso-spacerun:yes'>  </span>/* self pid */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> src_addr.nl_groups = 0;<span style='mso-spacerun:yes'>  </span>/* not in mcast groups */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> bind(sock_fd, (struct sockaddr*)&amp;src_addr, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>      </span>sizeof(src_addr));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> memset(&amp;dest_addr, 0, sizeof(dest_addr));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> dest_addr.nl_family = AF_NETLINK;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> dest_addr.nl_pid = 0;<span style='mso-spacerun:yes'>   </span>/* For Linux Kernel */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> dest_addr.nl_groups = 0; /* unicast */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh=(struct nlmsghdr *)malloc(<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>                         </span>NLMSG_SPACE(MAX_PAYLOAD));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* Fill the netlink message header */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh-&gt;nlmsg_pid = getpid();<span style='mso-spacerun:yes'>  </span>/* self pid */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh-&gt;nlmsg_flags = 0;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* Fill in the netlink message payload */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> strcpy(NLMSG_DATA(nlh), &quot;Hello you!&quot;);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> iov.iov_base = (void *)nlh;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> iov.iov_len = nlh-&gt;nlmsg_len;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_name = (void *)&amp;dest_addr;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_namelen = sizeof(dest_addr);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_iov = &amp;iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_iovlen = 1;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> sendmsg(fd, &amp;msg, 0);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* Read message from kernel */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> memset(nlh, 0, NLMSG_SPACE(MAX_PAYLOAD));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> recvmsg(fd, &amp;msg, 0);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> printf(&quot; Received message payload: %s\n&quot;, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>        </span>NLMSG_DATA(nlh));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>    </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'> </span>/* Close Netlink Socket */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> close(sock_fd);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>}<span style='mso-spacerun:yes'>    </span><o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>And, here is the kernel code:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct sock *nl_sk = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void nl_data_ready (struct sock *sk, int len)<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>{<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>  </span>wake_up_interruptible(sk-&gt;sleep);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>}<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void netlink_test() {<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> struct sk_buff *skb = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> struct nlmsghdr *nlh = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> int err;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> u32 pid;<span style='mso-spacerun:yes'>     </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'> </span>nl_sk = netlink_kernel_create(NETLINK_TEST, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>                                   </span>nl_data_ready);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* wait for message coming down from user-space */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> skb = skb_recv_datagram(nl_sk, 0, 0, &amp;err);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh = (struct nlmsghdr *)skb-&gt;data;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> printk(&quot;%s: received netlink message payload:%s\n&quot;, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>        </span>__FUNCTION__, NLMSG_DATA(nlh));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> pid = nlh-&gt;nlmsg_pid; /*pid of sending process */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).groups = 0; /* not in mcast group */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).pid = 0;<span style='mso-spacerun:yes'>      </span>/* from kernel */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).dst_pid = pid;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).dst_groups = 0;<span style='mso-spacerun:yes'>  </span>/* unicast */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> netlink_unicast(nl_sk, skb, pid, MSG_DONTWAIT);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> sock_release(nl_sk-&gt;socket);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>}<span style='mso-spacerun:yes'>    </span><o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>After loading the kernel module
that executes the kernel code above, when we run the user-space executable, we
should see the following dumped from the user-space program:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'>Received message payload: Hello you!<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>And, the following message should
appear in the output of dmesg:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'>netlink_test: received netlink message payload: <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>Hello you!<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<h2><a name=N0x850ca10.0x85d3260></a><span lang=EN style='font-size:16.0pt;
mso-ansi-language:EN'>4.6 Multicast Communication between Kernel and</span><span
lang=EN style='mso-ansi-language:EN'> </span><span lang=EN style='font-size:
16.0pt;mso-ansi-language:EN'>Applications<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>In this example, two user-space
applications are listening to the same netlink multicast group. The kernel
module pops up a message through netlink socket to the multicast group, and all
the applications receive it. Here is the user-space code:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>#include &lt;sys/socket.h&gt;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>#include &lt;linux/netlink.h&gt;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>#define MAX_PAYLOAD 1024<span style='mso-spacerun:yes'>  </span>/* maximum payload size*/<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct sockaddr_nl src_addr, dest_addr;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct nlmsghdr *nlh = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct iovec iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>int sock_fd;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void main() {<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> sock_fd=socket(PF_NETLINK, SOCK_RAW, NETLINK_TEST);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> memset(&amp;src_addr, 0, sizeof(local_addr));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> src_addr.nl_family = AF_NETLINK;<span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>   </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'> </span>src_addr.nl_pid = getpid();<span style='mso-spacerun:yes'>  </span>/* self pid */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* interested in group 1&lt;&lt;0 */<span style='mso-spacerun:yes'>  </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'> </span>src_addr.nl_groups = 1;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> bind(sock_fd, (struct sockaddr*)&amp;src_addr, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>      </span>sizeof(src_addr));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> memset(&amp;dest_addr, 0, sizeof(dest_addr)); <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'> </span>nlh = (struct nlmsghdr *)malloc(<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>                          </span>NLMSG_SPACE(MAX_PAYLOAD));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> memset(nlh, 0, NLMSG_SPACE(MAX_PAYLOAD));<span style='mso-spacerun:yes'>      </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>    </span><o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'> </span>iov.iov_base = (void *)nlh;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> iov.iov_len = NLMSG_SPACE(MAX_PAYLOAD);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_name = (void *)&amp;dest_addr;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_namelen = sizeof(dest_addr);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_iov = &amp;iov;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> msg.msg_iovlen = 1;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> printf(&quot;Waiting for message from kernel\n&quot;);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* Read message from kernel */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> recvmsg(fd, &amp;msg, 0);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> printf(&quot; Received message payload: %s\n&quot;, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>        </span>NLMSG_DATA(nlh));<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> close(sock_fd);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>}<span style='mso-spacerun:yes'>    </span><o:p></o:p></span></tt></pre>

<p><span lang=EN style='mso-ansi-language:EN'>And, here is the kernel code:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>#define MAX_PAYLOAD 1024 <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>struct sock *nl_sk = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>void netlink_test() {<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> sturct sk_buff *skb = NULL;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> struct nlmsghdr *nlh;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> int err;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nl_sk = netlink_kernel_create(NETLINK_TEST, <o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'><span style='mso-spacerun:yes'>                               </span>nl_data_ready);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> skb=alloc_skb(NLMSG_SPACE(MAX_PAYLOAD),GFP_KERNEL);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh = (struct nlmsghdr *)skb-&gt;data;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh-&gt;nlmsg_pid = 0;<span style='mso-spacerun:yes'>  </span>/* from kernel */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> nlh-&gt;nlmsg_flags = 0;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> strcpy(NLMSG_DATA(nlh), &quot;Greeting from kernel!&quot;);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* sender is in group 1&lt;&lt;0 */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).groups = 1;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).pid = 0;<span style='mso-spacerun:yes'>  </span>/* from kernel */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).dst_pid = 0;<span style='mso-spacerun:yes'>  </span>/* multicast */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /* to mcast group 1&lt;&lt;0 */<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> NETLINK_CB(skb).dst_groups = 1;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> /*multicast the message to all listening processes*/<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> netlink_broadcast(nl_sk, skb, 0, 1, GFP_KERNEL);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'> sock_release(nl_sk-&gt;socket);<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>}<span style='mso-spacerun:yes'>    </span><o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Assuming the user-space code is
compiled into the executable nl_recv, we can run two instances of nl_recv:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>./nl_recv &amp;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>Waiting for message from kernel<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>./nl_recv &amp;<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>Waiting for message from kernel<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN style='mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></p>

<p><span lang=EN style='mso-ansi-language:EN'>Then, after we load the kernel
module that executes the kernel-space code, both instances of nl_recv should
receive the following message:<o:p></o:p></span></p>

<pre><tt><span lang=EN style='mso-ansi-language:EN'>Received message payload: Greeting from kernel!<o:p></o:p></span></tt></pre><pre><tt><span
lang=EN style='mso-ansi-language:EN'>Received message payload: Greeting from kernel!<o:p></o:p></span></tt></pre><pre><span
lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></pre>

<h2><a name=N0x850ca10.0x85d3418></a><span lang=EN style='font-size:16.0pt;
mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></h2>

<h2><span lang=EN style='font-size:16.0pt;mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></h2>

<h2><span lang=EN style='font-size:16.0pt;mso-ansi-language:EN'>4.7 Summary<o:p></o:p></span></h2>

<p><span lang=EN style='mso-ansi-language:EN'>Netlink socket is a flexible
interface for communication between user-space applications and kernel modules.
It provides an easy-to-use socket API to both applications and the kernel. It
provides advanced communication features, such as full-duplex, buffered I/O,
multicast and asynchronous communication, which are absent in other
kernel/user-space IPCs.<o:p></o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN style='mso-ansi-language:EN'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><b><span lang=EN style='font-size:14.0pt;mso-ansi-language:
EN'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:13.5pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b><span style='font-size:13.5pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal align=center style='text-align:center'><b><span
style='font-size:13.5pt'><!--[if gte vml 1]><v:shape id="_x0000_i1032" type="#_x0000_t75"
 style='width:101.25pt;height:101.25pt'>
 <v:imagedata src="Project%20Report-N_files/image013.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=135 height=135
src="Project%20Report-N_files/image014.jpg" v:shapes="_x0000_i1032"><![endif]><o:p></o:p></span></b></p>

<p class=MsoNormal align=center style='text-align:center'><b><span
style='font-size:24.0pt'>Implementation</span></b><b style='mso-bidi-font-weight:
normal'><span style='font-size:24.0pt'><br>
</span></b><br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:16.0pt'>5.1 File System Type<br style='mso-special-character:
line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]><o:p></o:p></span></b></p>

<p class=MsoNormal>The filesystem is registered with the kernel during the
module initialization. During this step, two handlers get_sb and kill_sb are
used. get_sb is called at the time of mounting the file system. kill_sb is
called at the time of unmounting the file system. The get_sb handler uses the
kernel helper function get_sb_single to allocate the super block. We pass a
callback, emailfs_fill_super, to this function which will be called to fill the
super block structure. Since we dont have any specific task to do in the the
kill_sb handler, we can use the kernel helper function kill_anon_super.<br>
<br>
<b style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt'>5.2</span></b>
<b style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt'>Super
Block Operations<br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]><o:p></o:p></span></b></p>

<p class=MsoNormal>When a filesystem is mounted, the VFS calls the <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>get_sb</span></code>
function, which is responsible for filling the superblock structure it is
passed with appropriate values. For canonical filesystems, the superblock
contains information about the filesystem, such as the block size it uses,
where the root directory is located, and when it was last checked. The <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>get_sb</span></code>
function would then read the superblock, extract these values, and store them
in the appropriate fields in the superblock sturct.<b style='mso-bidi-font-weight:
normal'><span style='font-size:16.0pt'><o:p></o:p></span></b></p>

<p>Our filesystem will reside in RAM, and there will be no superblock to read.
The VFS provides a function named <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>get_sb_nodev</span></code>
for this case, which calls a specified filler function to put meaningful values
in the superblock struct. Thus, our <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>emailfs_get_sb</span></code>
reduces to:</p>

<pre><code><o:p>&nbsp;</o:p></code></pre>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static struct super_block * emailfs_get_sb(struct
file_system_type</span></b><span style='font-size:10.0pt;font-family:"Courier New"'>
*fs_type, int flags, const char *devname, void *data)<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<span style='mso-tab-count:
1'>     </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return get_sb_single(<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>           </span>fs_type,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>           </span>flags,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>           </span>data,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>          
</span>&amp;emailfs_fill_sb);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'>and <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>emailfs_fill_sb</span></code>
is defined as:</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>int emailfs_fill_sb(struct super_block *sb, void *data, int
silent)<o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_blocksize = 1024;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_blocksize_bits = 10;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_magic = EMFS_MAGIC;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_op = &amp;emailfs_sops; <span style='mso-tab-count:
2'>          </span><span style='mso-spacerun:yes'>    </span>// super block
operations<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_type = &amp;emailfs_type; <span style='mso-tab-count:
2'>        </span><span style='mso-spacerun:yes'>    </span>// file_system_type<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode = iget(sb, 1); <span style='mso-tab-count:
2'>        </span>// allocate an inode<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode-&gt;i_op = &amp;emailfs_iops;<span
style='mso-tab-count:1'> </span>// set the inode ops<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode-&gt;i_mode = S_IFDIR|S_IRWXU;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode-&gt;i_fop = &amp;emailfs_fops;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(!(sb-&gt;s_root = d_alloc_root(emailfs_root_inode)))<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>iput(emailfs_root_inode);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return -ENOMEM;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><br>
<br>
<b style='mso-bidi-font-weight:normal'><span style='font-size:16.0pt'>5.3 Inode
Operations<br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]><o:p></o:p></span></b></p>

<p class=MsoNormal>First, a short introduction to the concept of inodes. An
inode describes a file, that is, it contains information about the file type,
ownership and permissions, and the location of the file on disk. It does not
contain the name of the file, that role is reserved for directory entries. Some
filesystems (notably FAT) do not have the concept of inodes. A driver for such
a filesystem must make up something sensible whenever the VFS asks it to look
up an inode.</p>

<p>Since our filesystem resides in volatile memory, there are no inodes to
read. Instead, we fill the structure passed to us by the VFS with appropriate
values.</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>void emailfs_super_read_inode(struct inode *inode)</span></b><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>          </span>//here inodes are read from deamon<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime =
CURRENT_TIME;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>inode-&gt;i_mapping-&gt;a_ops = &amp;emailfs_aops;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:16.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:16.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:16.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:16.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='font-size:16.0pt'>5.4 File Operations</span></b><br style='mso-special-character:
line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></p>

<p class=MsoNormal>We'll register read, write and readdir handlers in the file
operations table. read and write handlers are called to read and write data
into the file. readdir is called to read the contents of a directory.<br>
<br>
The following table shows the fields we need to fill in the above data
structures.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="99%"
 style='width:99.66%;mso-cellspacing:0in;margin-left:.75pt;mso-padding-alt:
 1.5pt 1.5pt 1.5pt 1.5pt'>
 <tr style='mso-yfti-irow:0'>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>File System Type<o:p></o:p></b></p>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>Super Block<o:p></o:p></b></p>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>Inode<o:p></o:p></b></p>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>DEntry<o:p></o:p></b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1;mso-yfti-lastrow:yes'>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l3 level1 lfo1;tab-stops:list .5in'>name </li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l3 level1 lfo1;tab-stops:list .5in'><i>get_sb</i> </li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l3 level1 lfo1;tab-stops:list .5in'><i>kill_sb</i></li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l3 level1 lfo1;tab-stops:list .5in'>s_op</li>
  </ul>
  <p class=MsoNormal><o:p>&nbsp;</o:p></p>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;text-align:justify;mso-list:l6 level1 lfo2;tab-stops:list .5in'>s_root
       </li>
  </ul>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l11 level1 lfo3;tab-stops:list .5in'>i_ino </li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l11 level1 lfo3;tab-stops:list .5in'>i_mode</li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l11 level1 lfo3;tab-stops:list .5in'>i_op </li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l11 level1 lfo3;tab-stops:list .5in'>i_fop </li>
  </ul>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;text-align:justify;mso-list:l10 level1 lfo4;tab-stops:list .5in'>d_inode
       </li>
  </ul>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-align:justify'><br>
The following table shows the operation tables and the handlers used.</p>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width="99%"
 style='width:99.66%;mso-cellspacing:0in;margin-left:.75pt;mso-padding-alt:
 1.5pt 1.5pt 1.5pt 1.5pt'>
 <tr style='mso-yfti-irow:0'>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>Super Operations</b></p>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>File Operations<o:p></o:p></b></p>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>Inode Operations<o:p></o:p></b></p>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <p class=MsoNormal style='text-align:justify'><b>Address Space Operations<o:p></o:p></b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1;mso-yfti-lastrow:yes'>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l2 level1 lfo5;tab-stops:list .5in'><i>read_inode <o:p></o:p></i></li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l2 level1 lfo5;tab-stops:list .5in'><i>write_inode <o:p></o:p></i></li>
  </ul>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l1 level1 lfo6;tab-stops:list .5in'><i>read <o:p></o:p></i></li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l1 level1 lfo6;tab-stops:list .5in'><i>write <o:p></o:p></i></li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l1 level1 lfo6;tab-stops:list .5in'><i>readdir<o:p></o:p></i></li>
  </ul>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;text-align:justify;mso-list:l0 level1 lfo7;tab-stops:list .5in'><i>lookup
       <o:p></o:p></i></li>
  </ul>
  </td>
  <td valign=top style='padding:1.5pt 1.5pt 1.5pt 1.5pt'>
  <ul type=disc>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l8 level1 lfo8;tab-stops:list .5in'><i>readpage <o:p></o:p></i></li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l8 level1 lfo8;tab-stops:list .5in'><i>writepage <o:p></o:p></i></li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l8 level1 lfo8;tab-stops:list .5in'><i>prepare_write <o:p></o:p></i></li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l8 level1 lfo8;tab-stops:list .5in'><i>commit_write</i></li>
  </ul>
  </td>
 </tr>
</table>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><!--[if gte vml 1]><v:shape id="_x0000_i1033" type="#_x0000_t75"
 alt="" style='width:24pt;height:24pt;mso-wrap-distance-left:3pt;
 mso-wrap-distance-top:3pt;mso-wrap-distance-right:3pt;
 mso-wrap-distance-bottom:3pt'/><![endif]--><![if !vml]><img width=32
height=32 src="Project%20Report-N_files/image015.gif" hspace=4 vspace=4 v:shapes="_x0000_i1033"><![endif]></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><br>
<b><span style='font-size:16.0pt'>5.5 Entry points</span></b><br>
<br>
<b>a. init_module</b><br>
<br>
This is called when the module is loaded. We have to register our file system
here. Fill the file_system_type strucure with name and read_super fields and
call register_filesystem with the structure. For example,</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b><span
style='font-size:10.0pt;font-family:"Courier New"'>static struct
file_system_type emailfs</span> = {</b><br>
&nbsp;&nbsp;&nbsp; <span style='font-size:10.0pt;font-family:"Courier New"'>.name<span
style='mso-spacerun:yes'>           </span>= &quot;emailfs&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span
style='mso-spacerun:yes'>  </span>.get_sb<span
style='mso-spacerun:yes'>         </span>= emailfs_get_sb,<span
style='mso-tab-count:1'> </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span
style='mso-spacerun:yes'>  </span>.kill_sb<span
style='mso-spacerun:yes'>        </span>= emailfs_kill_sb<span
style='mso-tab-count:1'> </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'>};<br>
<br>
<b style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;
font-family:"Courier New"'>static int emailfs_init_module(void)</span></b><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk( KERN_DEBUG &quot;Module emailfs init\n&quot; );<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>register_filesystem(&amp;emailfs_type);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><b>b. file_system_type.get_sb</b><br>
<br>
This will be called when the file system is mounted. We have to return a super
block. We use the helper function get_sb_simple to do the super block
allocation and also passing emailfs_fill_super callback to fill the super block
object. The s_op field is set with the address of the super block operations
table emailfs_sops. The root most inode of the file system has to be allocated
at this stage. The dentry for it should be set on the s_root field of the super
block. As mentioned earlier, this is the entry point of lookup operations into
the file system.<br>
<br>
The inode object is allocated using the function iget. After initializing the
inode, the dentry is allocated using the function d_alloc_root. This dentry is
set to the s_root field of the super block.</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>int emailfs_fill_sb(struct super_block *sb, void *data, int
silent)<o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>//static int;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_blocksize = 1024;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_blocksize_bits = 10;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_magic = EMFS_MAGIC;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_op = &amp;emailfs_sops; <span style='mso-tab-count:
3'>                </span>// super block operations<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>sb-&gt;s_type = &amp;emailfs_type; <span style='mso-tab-count:
3'>              </span>// file_system_type<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode = iget(sb, 1); <span style='mso-tab-count:
2'>        </span>// allocate an inode<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode-&gt;i_op = &amp;emailfs_iops;<span
style='mso-tab-count:1'> </span>// set the inode ops<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode-&gt;i_mode = S_IFDIR|S_IRWXU;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>emailfs_root_inode-&gt;i_fop = &amp;emailfs_fops;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(!(sb-&gt;s_root = d_alloc_root(emailfs_root_inode)))<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>iput(emailfs_root_inode);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return -ENOMEM;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><br>
<b style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;
font-family:"Courier New"'>static struct super_block * emailfs_get_sb(struct
file_system_type</span></b><span style='font-size:10.0pt;font-family:"Courier New"'>
<b style='mso-bidi-font-weight:normal'>*fs_type, int flags, const char
*devname, void *data)<o:p></o:p></b></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<span style='mso-tab-count:
1'>     </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return get_sb_single(<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>           </span>fs_type,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>         </span><span
style='mso-spacerun:yes'>  </span>flags,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>           </span>data,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>          
</span>&amp;emailfs_fill_sb);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'>Let us assume that our file
system is mounted under /mnt/emailfs.<br>
<br>
<b>c. file_system_type.kill_sb</b><br>
<br>
This is called at the time of unmounting the file system. We use the helper
function kill_anon_super for this.</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static void emailfs_kill_sb(struct super_block *super)<o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>kill_anon_super(super);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><br>
<br>
<b>d. super_operations.read_inode</b><br>
<br>
Inodes objects should be allocated using the iget function. This uses the inode
cache, adjusts the relationships of the inode with various data structures,
updates the count etc. If the inode is not cached, it allocates a new inode and
calls the read_inode handler of the super block if present. Inodes are
identified by the inode numbers. The handler is expected to initialize the inode
with the contents of the inode on the backend.<br>
<br>
<b>e. super_operations.write_inode</b><br>
<br>
This will be called when the dirty inodes are flushed. The handler has to sync
the inode contents to the backend.</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static int emailfs_super_write_inode(struct inode *inode, int
wait)<o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk(&quot;emailfs_super_write_inode (i_ino = %d) =
%d\n&quot;,(int)inode-&gt;i_ino,(int)i_size_read(inode));<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(inode-&gt;i_ino == FILE_INODE_NUMBER||inode-&gt;i_ino == 3)<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>file_size = i_size_read(inode);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><br>
<br>
<b>d. inode_operations.lookup</b><br>
<br>
This will be called when the kernel is resolving a path. The lookup handler of
the inode operation table of the parent inode is called to resolve a child.
Remember that the dentry for the root most inode is already available in s_root
field of the super block.<br>
<br>
For example, after mounting the file system under '/mnt/emailfs' if we want to
see the contents using 'ls /mnt/emailfs', the kernel has to create a file
object for the inode '/mnt/emailfs'. The kernel will create a file object with
the dentry of the root most inode of the file system. For the command 'ls -l
/mnt/emailfs/hello.txt', the kernel name lookup reaches the root most inode and
the lookup handler will be called to set the inode of 'hello.txt'. The kernel
allocates the dentry object and passes to the handler. If an inode exists for
the name component, the inode has to be added to the dentry using d_add and
NULL should be returned. If there is some problem, a suitable error code has to
be returned.<br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static struct dentry * emailfs_inode_lookup(struct inode
*parent_inode,</span></b><span style='font-size:10.0pt;font-family:"Courier New"'>
<b style='mso-bidi-font-weight:normal'>struct dentry *dentry, struct nameidata
*nameidata)<o:p></o:p></b></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>struct inode *file_inode;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>DEBG(&quot;LOOKUP&quot;);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(parent_inode-&gt;i_ino != emailfs_root_inode-&gt;i_ino )<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>printk(&quot;nulled = %s\n&quot;,dentry-&gt;d_name.name);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>d_add(dentry, NULL);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>goto out;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk(&quot;allocated =%s\n&quot;,dentry-&gt;d_name.name); <span
style='mso-tab-count:3'>             </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>file_inode = iget(parent_inode-&gt;i_sb, FILE_INODE_NUMBER);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>file_inode = iget(parent_inode-&gt;i_sb, 3);*/<span
style='mso-tab-count:3'>                 </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(!file_inode)<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return ERR_PTR(-EACCES);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>file_inode-&gt;i_size = file_size;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>file_inode-&gt;i_mode =
S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>file_inode-&gt;i_fop = &amp;emailfs_fops;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>d_add(dentry, file_inode);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>out:<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return NULL;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><br>
<b>e. file_operations.readdir</b><br>
<br>
This will be called when the kernel wants to read the contents of a directory.
The readdir handler of the file operations table of the file will be called to
show the contents of the directory. The kernel passes the file object, the
dirent structure and a callback to fill the dirent structure with the values of
the contents of the directory. The values are added to the dirent structure
using the 'filldir' callback. Since we support one hardcoded file 'hello.txt',
we just have to return the values, '.', '..' and 'hello.txt'. File systems like
ext2 will have to fetch the contents from the disk.</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static int emailfs_file_readdir(struct file *file, void *dirent,</span></b><span
style='font-size:10.0pt;font-family:"Courier New"'> <b style='mso-bidi-font-weight:
normal'>filldir_t filldir)<o:p></o:p></b></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>struct dentry *de = file-&gt;f_dentry;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>struct sock *nl_sk=NULL;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>DEBG(&quot;READDIR&quot;);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk(&quot;INODE
:%s\n&quot;,file-&gt;f_dentry-&gt;d_name.name);<span style='mso-tab-count:1'>    </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>daemon_send(nl_sk);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(file-&gt;f_pos &gt; 2)<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return 1;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(filldir(dirent, &quot;.&quot;, 1, file-&gt;f_pos++,
de-&gt;d_inode-&gt;i_ino, <span style='mso-spacerun:yes'>     </span>DT_DIR))<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(filldir(dirent, &quot;..&quot;, 2, file-&gt;f_pos++,
de-&gt;d_parent-&gt;d_inode-&gt;i_ino, DT_DIR))<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(filldir(dirent, &quot;hello.txt&quot;, 9, file-&gt;f_pos++,
FILE_INODE_NUMBER, DT_REG))<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(filldir(dirent, &quot;hello2.xt&quot;, 9, file-&gt;f_pos++,
3, DT_REG))<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return 1;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><br>
In our file system, we are supporting only one file i.e., hello.txt. So, the
result of 'ls /mnt/emailfs' will be<br>
<b><span style='font-family:"Courier New"'>. .. hello.txt</span></b><br>
<br>
<br>
<b>f. file_operations.read</b><br>
<br>
This will be called when the kernel gets a read request for a file in our file
system. The file object of the file to be read, the user-space buffer address,
the maximum size of the buffer and the address of the offset (which contains
the current offset and which has to be updated after successful read operation)
are passed. The contents of the file have to be written to the buffer. Note
that this is in the user-space. The data is copied to the user-space buffer
using the function copy_to_user.<br>
<br>
There are two ways of supporting this operation. One way is to provide a read
handler which writes the data to the buffer. But the drawback is that we cannot
take advantage of the page cache. Files can also be read/written using the mmap
(memory mapping). With this approach, we cannot support the mmap way of
accessing the file (or it is very difficult to provide transparency i.e., file
written after mapping and read with 'read' system call).<br>
The second way is to provide a unified way to read/write to the file for both
the approaches i.e., calling the system calls directly or by mapping the file
and reading/writing the contents in memory). This takes the advantage of page
cache also. This is applicable to the write operation also.<br>
<br>
Let us take the second approach (the code for the first approach is also
provided later). The approach is slightly different in this case. The contents
of an inode are seen as chunks of pages and represented by addess_space object.
This 'mapping' between the inode and the address space object is stored in the
i_mapping field of the inode. To read some data from the page, the
corresponding chunks/pages which holds the data are loaded into memory.<br>
<br>
Address Space Operations table is used to perform different operations on the
address space object (a_ops field). The readpage handler of the table is used
to read the contents of a page of the inode into memory. For example, if the
page size is 4096, the data from 5000 to 6000 bytes is present in the 2nd page
of the inode (similarly, the data from 4000 to 5000 is present in the pages 1
and 2).<br>
<br>
Since the actual work of reading the data is moved to
address_space_operations.readpage handler, we can use the generic_file_read
helper function as the read handler. This function get the pages of the data
and copies to the user-space buffer. If the pages are not in the cache, it
waits till the pages are loaded with the data using the 'readpage' handler.<br>
<br>
<b>g. address_space_operations.readpage</b><br>
<br>
The readpage handler has to fill the page with the contents of the inode. The
index of the page is obtained from the 'index' field of the page structure.</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static int emailfs_readpage(struct file *file, struct page
*page)<o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<span style='mso-tab-count:
1'>     </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>char buff[10];<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>DEBG(&quot;READPAGE&quot;);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk(&quot;filename = %s&quot;,file-&gt;f_dentry-&gt;d_name.name);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk(&quot;EMFS: readpage called for page index=[%d]\n&quot;,
(int)page-&gt;index);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(page-&gt;index &gt; 0)<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>return -ENOSPC;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk(&quot;EMFS: Page: [%s] [%s] [%s] [%s]\n&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>       </span>PageUptodate(page)
? &quot;Uptodate&quot; : &quot;Not Uptodate&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>       </span>PageDirty(page) ?
&quot;Dirty&quot; : &quot;Not Dirty&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>      
</span>PageWriteback(page) ? &quot;PageWriteback Set&quot; :
&quot;PageWriteback Cleared&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>       </span>PageLocked(page) ?
&quot;Locked&quot; : &quot;Unlocked&quot;);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>SetPageUptodate(page);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>memcpy(page_address(page), file_buf, PAGE_SIZE);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(PageLocked(page))<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>unlock_page(page);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-bottom:12.0pt'><br>
<b>h. file_operations.write</b><br>
<br>
We register generic_file_write as the write handler. This allocates pages and
calls prepare_write handler on the address space object so that buffer head
objects can be allocated for the page to perform the I/O to the device later.
It copies the data from the user-space to the pages and calls commit_write on
the address space object.<br>
File systems like ext2 generally have a specific implementation of
prepare_write. The allocation of buffer head objects for the write operation
will be same for most of the file systems except for the location of the buffer
heads (buffer head is the kernel's copy of a disk block). In this case, they
use the helper/wrapper function block_prepare_write and passing a callback (in
case of ext2, it is ext2_get_block) which will give the block number for the
file offset.<br>
<br>
Since writing the buffers associated with the pages to the device is similar to
most of the file systems, they normally use generic_commit_write helper function.
This marks the buffer as dirty so that it will be flushed later to the device
by the block device layer.<br>
<br>
This writes the data from user-space to the pages. The pages are synced later.
Note that the read/write happens on the cached pages.<br>
<br>
<b>i. address_space_operations.commit_write</b><br>
<br>
The generic_commit_write helper function sets up the buffers to be written to
the disk. Since we are not using any device, this has been modified to write
into the memory buffer of the file.</p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static int emailfs_commit_write(struct file *file, struct page</span></b><span
style='font-size:10.0pt;font-family:"Courier New"'> <b style='mso-bidi-font-weight:
normal'>*page,unsigned from, unsigned to)<o:p></o:p></b></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>struct inode *inode = page-&gt;mapping-&gt;host;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>loff_t pos = ((loff_t)page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT)
+ to;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk(&quot;EMFS: commit_write: [%s] [%s] [%s] \n&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>       </span>PageUptodate(page)
? &quot;Uptodate&quot; : &quot;Not Uptodate&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>       </span>PageDirty(page) ?
&quot;Dirty&quot; : &quot;Not Dirty&quot;,<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span><span style='mso-spacerun:yes'>       </span>PageLocked(page) ?
&quot;Locked&quot; : &quot;Unlocked&quot;);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if(page-&gt;index == 0)<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>memcpy(file_buf, page_address(page), PAGE_SIZE);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>ClearPageDirty(page);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>/*<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>* No need to use i_size_read() here, the i_size<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>* cannot change under us because we hold i_sem.<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>*/<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>if (pos &gt; inode-&gt;i_size)<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>{<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>i_size_write(inode, pos);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
2'>            </span>mark_inode_dirty(inode);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>}<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>SetPageUptodate(page);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>return 0;<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal><b>j. cleanup_module</b><br>
<br>
This will be called when the module is removed. We have to unregister our file
system at this point. The module count will be incremented and decremented by
the file system calls. So the module will not be removed if the module use
count is not zero. The kernel takes care of this, so we need not do anything to
check if our file system is in use.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><b
style='mso-bidi-font-weight:normal'><span style='font-size:10.0pt;font-family:
"Courier New"'>static void emailfs_exit_module(void)<o:p></o:p></span></b></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>{<span style='mso-tab-count:
1'>     </span><o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>printk( KERN_DEBUG &quot;Module emailfs exit\n&quot; );<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>//<span style='mso-tab-count:
1'>    </span>strcpy(buff,&quot;CONNEXIT&quot;);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>//<span style='mso-tab-count:
1'>    </span>daemon_send(buff,0);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'><span style='mso-tab-count:
1'>      </span>unregister_filesystem(&amp;emailfs_type);<o:p></o:p></span></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:10.0pt;font-family:"Courier New"'>}<o:p></o:p></span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
